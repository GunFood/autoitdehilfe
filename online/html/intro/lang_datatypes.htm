<!DOCTYPE html>
<html>
<head>
	<title>Sprachreferenz - Datentypen</title>
	<meta charset="utf-8">
	<link href="../css/default.css" rel="stylesheet">
</head>
<body>
	<h1>Sprachreferenz - Datentypen</h1>
	<p>In AutoIt gibt es nur einen Datentyp, namens <strong>Variant</strong>. Ein Variant kann numerische oder Zeichendaten enthalten und entscheidet &uuml;ber deren Nutzung, abh&auml;ngig von der Situation, in der diese Daten genutzt werden. Zum Beispiel, wenn versucht wird zwei Variants zu multiplizieren, werden sie als Zahlen behandelt, wenn versucht wird zwei Variants zu verketten (verbinden), werden sie als Zeichenketten behandelt.</p>
	<p>Einige Beispiele:</p>
	<p>10 * 20 entspricht der <strong>Zahl</strong> 200 (<strong>*</strong> wird genutzt um zwei Zahlen zu multiplizieren)</p>
	<p>10 * "20" entspricht der <strong>Zahl</strong> 200</p>
	<p>"10" * "20" entspricht der <strong>Zahl</strong> 200</p>
	<p>10 & 20 entspricht der <strong>Zeichenkette</strong> "1020" (<strong>&</strong> wird genutzt um Zeichenketten zu verbinden)</p>
	<p></p>
	<p>Wenn eine Zeichenkette als Zahl benutzt wird, wird ein impliziter Aufruf von <strong><a href="../functions/Number.htm">Number()</a></strong> vollzogen. Sollte die Zeichenkette nun keine g&uuml;ltige Zahl enthalten, wird angenommen, dass der Wert 0 entspricht. Zum Beispiel,</p>
	<p>10 * "fgh" entspricht der Zahl <strong>0</strong>.</p>
	<p>Wenn eine Zeichenkette als Wahrheitswert (boolean) benutzt wird und es ist eine leere Zeichenkette "" , wird angenommen, dass der Wert "nicht wahr" (false) entspricht (siehe unten). Zum Beispiel,</p>
	<p>NOT "" entspricht dem Wahrheitswert <strong>True</strong>.</p>
	<h2>Zahlen</h2>
	<p>Zahlen k&ouml;nnen standardm&auml;&szlig;ige Zahlen sein, wie <strong>2</strong>, <strong>4.566</strong>, und <strong>-7</strong>.</p>
	<p>Wissenschaftliche Schreibweise wird ebenso unterst&uuml;tzt; deshalb kann <strong>1.5e3</strong> anstatt <strong>1500</strong> geschrieben werden.</p>
	<p>Integer (ganze Zahlen) k&ouml;nnen gleichwohl in hexadezimaler Schreibweise repr&auml;sentiert werden, dem Integer voranstellend <strong>0x</strong> wie in <strong>0x409</strong> oder <strong>0x4fff</strong> (wenn Hex-Notation genutzt wird sind nur 32-bit Zahlen g&uuml;ltig).</p>
	<h2>Zeichenketten (Strings)</h2>
	<p>Zeichenketten sind in doppelten Anf&uuml;hrungszeichen eingeschlossen, wie <strong>"diese"</strong>. Wenn eine Zeichenkette doppelte Anf&uuml;hrungszeichen enthalten soll schreibt man es zweifach wie:</p>
	<p><strong>"Hier ist ein ""doppeltes Anf&uuml;hrungszeichen"" - OK ?"</strong></p>
	<p>Einfache Anf&uuml;hrungszeichen k&ouml;nnen ebenso genutzt werden wie <strong>'diese'</strong> und <strong>'Hier ist ein ' 'einfaches Anf&uuml;hrungszeichen' ' - OK ?'</strong></p>
	<p></p>
	<p>Anf&uuml;hrungszeichen k&ouml;nnen f&uuml;r einfacheren Umgang gemischt werden, z. Bsp. um Verdoppelung zu vermeiden, damit das gew&uuml;nschte Ergebnis erreicht wird. Zum Beispiel, wenn mehrere doppelte Anf&uuml;hrungszeichen in einer Zeichenkette enthalten sind, dann sollte man einfache Anf&uuml;hrungszeichen f&uuml;r die Deklaration nutzen:</p>
	<p><strong>'Dieser "Satz" enth&auml;lt "viele" "doppelte Anf&uuml;hrungszeichen", nicht wahr?'</strong></p>
	<p>ist wesentlich einfacher als:</p>
	<p><strong>"Dieser ""Satz"" enth&auml;lt ""viele"" "doppelte Anf&uuml;hrungszeichen", nicht wahr?"</strong></p>
	<p>Bei Auswertung von Zeichenketten, k&ouml;nnen diese Env oder Var Variablen repr&auml;sentieren, gem&auml;&szlig; der <a href="../functions/AutoItSetOption.htm#ExpandEnvStrings">Opt()</a> Funktionsdefinition.</p>
	<p>Alle AutoIt Strings verwenden UTF-16 (geanuer gesagt UCS-2) Codierung.</p>
	<h2>Wahrheitswerte (Booleans)</h2>
	<p>Wahrheitswerte (Booleans) sind <strong>logische</strong> Werte. Es existieren nur zwei Zust&auml;nde: <strong>wahr</strong>(True) und <strong>nicht wahr</strong>(False).<br>
	<br>
	Sie k&ouml;nnen in Zuweisungen von Variablen genutzt werden, zusammen mit den Boolean Operatoren <strong>and</strong>, <strong>or</strong> und <strong>not</strong>.<br>
	<br>
	Beispiel:<br>
	$bBoolean1 = True<br>
	$bBoolean2 = False<br>
	$bBoolean3 = $bBoolean1 And $bBoolean2<br>
	<br>
	Das Ergebnis in $bBoolean3 ist demnach <strong>False</strong><br>
	<br>
	$bBoolean1 = False<br>
	$bBoolean2 = Not $bBoolean1<br>
	<br>
	Das Ergebnis in $bBoolean2 ist demnach <strong>True</strong><br>
	<br>
	<br>
	Falls ein Boolean zusammen mit Zahlen verwendet werden, gelten folgende Regeln:<br>
	<br>
	Ein Wert 0 entspricht dem Boolean von <strong>False</strong><br>
	Jede andere Zahl entspricht dem Boolean von <strong>True</strong><br>
	<br>
	Beispiel:<br>
	$iNumber1 = 0<br>
	$bBoolean1 = true<br>
	$bBoolean2 = $iNumber1 und $bBoolean1<br>
	<br>
	Das Ergebnis in $bBoolean2 ist demnach <strong>False</strong><br>
	<br>
	<br>
	Wenn arithmetische zusammen mit Wahrheitswerten genutzt werden (<strong>was nicht ratsam ist!</strong>), gelten folgende Regeln:<br>
	<br>
	Ein Boolean true wird konvertiert, in den numerischen Wert <strong>1</strong><br>
	Ein Boolean false wird konvertiert, in den numerischen Wert <strong>0</strong><br>
	<br>
	Beispiel:<br>
	$bBoolean1 = true<br>
	$iNumber1 = 100<br>
	$iNumber2 = $bBoolean1 + $iNumber1<br>
	<br>
	Das Ergebnis in $iNumber2 ist der numerischen Wert 101<br>
	<br>
	<br>
	Wenn Zeichenketten zusammen mit Wahrheitswerten genutzt werden, werden diese wie folgt konvertiert:<br>
	<br>
	Ein Boolean true enth&auml;lt die Zeichen <strong>"True"</strong><br>
	Ein Boolean false enth&auml;lt die Zeichen <strong>"False"</strong><br>
	<br>
	Beispiel:<br>
	$bBoolean1=true<br>
	$String1="Test ist: "<br>
	$String2=$String1 & $bBoolean1<br>
	<br>
	Das Ergebnis in $String2 ist die Zeichenkette "Test ist: True"<br>
	<br>
	Umgekehrt ist es anders. Wenn Zeichenketten mit Wahrheitswerten verglichen werden, gelten folgende Regeln:<br>
	Nur eine leere Zeichenkette ("") ist ein Boolean <strong>False</strong><br>
	Jede andere Zeichenkette mit Werten (einschlie&szlig;lich einer Zeichenkette wie "0") ist ein Boolean <strong>True</strong><br></p>
	<h2>Bin&auml;rdaten</h2>
	<p>Bin&auml;rdaten k&ouml;nnen jegliche Bitwerte aufnehmen. Sie werden in ihre hexadezimale Repr&auml;sentation konvertiert, wenn sie in einer Zeichenkette gespeichert werden. Beispiel:<br>
	$dBin = Binary ("abc")<br>
	$sString = String ($dBin) ; "0x616263"</p><br>
	<h2>Zeiger (Pointer)</h2>
	<p>Zeigertypen enthalten eine 32bittige oder 64bittige Speicheradresse, je nach dem davon abh&auml;ngig, ob die 32bit oder 64bit Version von AutoIt genutzt wird. Sie werden in ihre hexadezimale Repr&auml;sentation konvertiert, wenn sie in einer Zeichenkette gespeichert werden. Fensterhandles (HWnd) wie von <a href="../functions/WinGetHandle.htm">WinGetHandle</a> zur&uuml;ckgegeben, sind Zeigertypen.<br>
	<br>
	Variablen die mit <a href="../functions/DllStructCreate.htm">DllStructCreate()</a> erstellt wurden, k&ouml;nnen als Pointer verwendet werden, wenn ein 'struct*' Typ in <a href="../functions/DllCall.htm">DllCall()</a> verwendet wird.<br>
	Falls ein Pointer durch <a href="../functions/DllStructGetPtr.htm">DllStructGetPtr()</a> definiert wurde, kann ein solcher Parameter mit einem 'struct*' Typ &uuml;bergeben werden.</p>

	<h2>Datentypen und Einstufungen</h2>
	<p>Die folgende Tabelle zeigt die internen Variant Datentypen und deren Einstufung.</p>
	<table>
		<tr>
			<th>Sub-Datentyp</th>
			<th>Einstufung und Bemerkungen</th>
		</tr>
		<tr>
			<td>Int32</td>
			<td>Ein 32bit vorzeichenbehafteter Integer (Ganzzahl).</td>
		</tr>
		<tr>
			<td>Int64</td>
			<td>Ein 64bit vorzeichenbehafteter Integer (Ganzzahl)</td>
		</tr>
		<tr>
			<td>Double</td>
			<td>Eine doppelt-pr&auml;zise Flie&szlig;komma Zahl (double).</td>
		</tr>
		<tr>
			<td>Zeichenkette</td>
			<td>Kann bis zu 2147483647 Zeichen aufnehmen.</td>
		</tr>
		<tr>
			<td>Bin&auml;rdaten</td>
			<td>Bin&auml;rdaten k&ouml;nnen bis zu 2147483647 Bytes aufnehmen.</td>
		</tr>
		<tr>
			<td>Zeiger</td>
			<td>Ein Zeiger auf eine Speicheradresse. 32 Bit oder 64 Bit abh&auml;ngig von der genutzten AutoIt Version.</td>
		</tr>
	</table>
	<p></p>
	<p>Manche Funktionen in AutoIt arbeiten ausschlie&szlig;lich mit 32bittigen Zahlen (z. B. <a href="../functions/BitAND.htm">BitAND</a>) und konvertieren diese automatisch - Diese Funktionen sind dokumentiert, wenn erforderlich.</p>
</body>
</html>
